// Author: Tove Nordmark
// Package hamming provides encoding and decoding using error correcting codes
// The codes used are linear codes, specifically Hamming codes

package hamming

import (
	"fmt"
)

// powTwo returns the nth power of 2
func powTwo(n int) int{
	return 1<<n
}

// vecMatMul multiplies the vector v (n) with the matrix A (n x m)
func vecMatMul(v []bool, A [][]bool) []bool {
	n := len(v)
	m := len(A[0])
	result := make([]bool, m)
	elem := false
	for j := 0; j < m; j++{
		for i := 0; i < n; i++{
			// Multiplication in Z_2 is equivalent to AND
			// Adding in Z_2 is equivalent to XOR
			elem = elem != (v[i] && A[i][j])
		}
		result[j] = elem
		elem = false
	}
	return result
}

func matString(A [][]bool) string {
	nRows := len(A)
	nCols := len(A[0])
	result := "["
	row := ""
	for i := 0; i < nRows; i++{
		if i > 0{
				row += " ["
		} else {
			row += "["
		}
		for j := 0; j < nCols; j++{
			spaceChar := " "
			if j == nCols - 1{
				spaceChar = ""
			}
			if A[i][j]{
				row += "1" + spaceChar
			} else {
				row += "0" + spaceChar
			}
		}
		if i == nRows - 1 {
			result += row + "]]" + "\n"
		} else {
		result += row + "]," + "\n"
		row = ""
		}
	}
	return result
}

// makeMat makes a boolean matrix of the specified dimensions
func makeMat(nRows int, nCols int) [][]bool{
	result := make([][]bool, nRows)
	for i := range result {
		result[i] = make([]bool, nCols)
	}
	return result
}

// returns the transpose of A
func transpose(A [][]bool) [][]bool {
	nRows := len(A)
	nCols := len(A[0])
	AT := makeMat(nCols, nRows)
	for i := 0; i < nRows; i++{
		for j := 0; j < nCols; j++{
			AT[j][i] = A[i][j]
		}
	}
	return AT
}

// returns the kth bit in the binary representation of n
func intBit(n int, k int) bool{
	kthBit := (n >> k) & 1
	return !(kthBit % 2 == 0)
}

func byteInt(word [8]bool) int{
	result := 0
	for i, bit := range word{
		if bit{
		result |= (1 << (7 - i))
		}
	} 
	return result
}

// The struct holds the necessary information
// for decoding and encoding words,
// and for error correction
// H is the check matrix and G is the generator matrix
// n is the parameter of the 
type Code struct {
	h     [][]bool
	ht	  [][]bool
	g     [][]bool
	m     int
	n	  int
	k	  int
}

// Generates a new code according to the specifications
// Hamming code H(n, k) = H(2^m, 2^m - m - 1)
func New(m int) Code{

	n := powTwo(m) - 1
	k := powTwo(m) - m - 1
	var newCode Code

	// Generate H
	// Columns of H are generated by
	// counting in binary, but 
	// putting all powers of two
	// at the end of H
	newCode.h = makeMat(m, n)
	skipped := 0
	for i := 1; i < n + 1; i++{
		if i & (i - 1) == 0{ // Check if power of two
			skipped++
		} else {
			for j := 0; j < m; j++ {
				newCode.h[j][i - skipped - 1] = intBit(i, j)
			}
		}
	}
	for i := 0; i < m; i++{
		newCode.h[i][n - skipped + i] = true
	}

	newCode.ht = transpose(newCode.h)

	// Generate G
	// G is generated by concatenating an identity matrix
	// with the transpose of the left side of H
	newCode.g = makeMat(k, n)
	for i := 0; i < n - m; i++{
		newCode.g[i][i] = true
	}
	for i := 0; i < n - m; i++{
		for j := 0; j < m; j++ {
			newCode.g[i][j + n - m] = newCode.h[j][i]
		}
	}
		
	newCode.m= m
	newCode.n = n
	newCode.k = k
	return newCode
}

// encodeByte generates the code word for the byte x
func (c Code) encodeWord(x []bool) []bool {
	return vecMatMul(x, c.g)
}

// decodeWord converts the code word y to the corresponding word
func (c Code) decodeWord(y []bool) ([]bool, bool) {
	syndrome := vecMatMul(y, c.ht)
	
	// Check if there is no error
	bitFlip := false
	for _, bit := range syndrome{
		if bit{
			bitFlip = true
		}
	}
	if !bitFlip{
		return y[:c.k], false
	}
	
	// Detect where the error is:
	var errorBit int
	for i := 0; i < c.n; i++{
		done := true
		for j := 0; j < c.m; j++{
			if syndrome[j] != c.h[j][i]{
				done = false
				break
			}
		}
		if done{
			errorBit = i
			break
		}
	}
	result := y
	// Correct error
	result[errorBit] = !result[errorBit]
	return result[:c.k], true

}

// Encode converts a sequence of words to the corresponding
// sequence of code words.
func (c Code) EncodeBin(words []bool) []bool {
	messageLength := len(words)
	remainder := messageLength % c.k
	var nBlocks int
	var loopLength int
	if remainder == 0{
		nBlocks = messageLength / c.k
		loopLength = nBlocks
	} else {
		nBlocks = messageLength / c.k + 1
		loopLength = nBlocks - 1
	}
	
	result := make([]bool, nBlocks * c.n)
	word := make([]bool, c.k)
	// Encode data by partitioning it into words
	// of length k
	for i := 0; i < loopLength; i++{
		for j := 0; j < c.k; j++{
			word[j] = words[i*c.k + j]
		}
		codeWord := c.encodeWord(word)
		for j, bit := range codeWord{
			result[i*c.n + j] = bit
		}
	}
	if remainder != 0{
		for i := 0; i < remainder; i++{
			word[i] = words[loopLength * c.k + i]
		}
		for i := remainder; i < c.k; i++{
			word[i] = false
		}
		codeWord := c.encodeWord(word)
		for j, bit := range codeWord{
			result[loopLength * c.n + j] = bit
		}
	}
	return result
}

// Encode returns the binary words from an encoded message
// Also, the positions of the errors, as in which words
// contain errors, are returned
func (c Code) DecodeBin(words []bool, remainder int) ([]bool, []int) {
	nBlocks := len(words) / c.n
	codeWord := make([]bool, c.n)
	var message []bool
	var loopLength int
	if remainder != 0{
		message = make([]bool, (nBlocks - 1) * c.k + remainder)
		loopLength = nBlocks - 1
	} else {
		message = make([]bool, nBlocks * c.k)
		loopLength = nBlocks
	}
	var bitFlips []int
	// Encoded data consists of blocks of length n
	for i := 0; i < loopLength; i++{
		for j := 0; j < c.n; j++{
			codeWord[j] = words[i*c.n + j]
		}
		word, bitFlip := c.decodeWord(codeWord)
		if bitFlip{
			bitFlips = append(bitFlips, i)
		}
		for j, bit := range word{
			message[i*c.k + j] = bit
		}
	}
	
	if remainder != 0{
		for i := 0; i < c.n; i++{
			codeWord[i] = words[loopLength*c.n + i]
		}
		word, bitFlip := c.decodeWord(codeWord)
		for j := 0; j < remainder; j++{
			message[(nBlocks - 1) * c.k + j] = word[j]
		}
		if bitFlip{
			bitFlips = append(bitFlips, loopLength)
		}
	}
	return message, bitFlips
}

// EncodeString converts plain text to the corresponding
// sequence of code words.
func (c Code) EncodeString(words string) []bool {
	binMessage := make([]bool, 8*len(words))
	for i, letter := range words{
		for k := 0; k < 8; k++{
			binMessage[8 * i + k] = intBit(int(letter), 7 - k) // ASCII code
		}
	}
	return c.EncodeBin(binMessage)
}

// DecodeString converts binary code words to the corresponding string
func (c Code) DecodeString(words []bool, remainder int) (string, []int){
	binMessage, bitFlips := c.DecodeBin(words, remainder)
	nChars := len(binMessage) / 8
	message := ""
	var binChar [8]bool
	for i := 0; i < nChars; i++{
		for j := 0; j < 8; j++{
			binChar[j] = binMessage[8*i + j]
		}
		message += string(rune(byteInt(binChar)))
	}
	nBitFlips := len(bitFlips)
	errorPlacements := make([]int, nBitFlips)
	for i := 0; i < nBitFlips; i++{
		errorPlacements[i] = bitFlips[i] * c.k / 8
	}
	return message, errorPlacements
}

func (c Code) Print(){
	fmt.Printf("Hamming Code H(%d, %d)\n",c.n, c.k )
	fmt.Println("Block Length m: ", c.n)
	fmt.Println("Word Length k: ", c.k)
	fmt.Println("Minimum Distance delta: ", 3, "(Corrects one error and detects two)")
	fmt.Println("H = ")
	fmt.Print(matString(c.h))
	fmt.Println("G = ")
	fmt.Print(matString(c.g))
}